module Database.PostgreSQL.Query.Functions
       ( -- * Raw query execution
         pgQuery
       , pgQueryWithMasker
       , pgExecute
       , pgExecuteWithMasker
       , pgQueryEntities
         -- * Transactions
       , pgAtomically
       , pgWithSavepoint
       , pgWithTransactionMode
       -- , pgWithTransactionModeRetry
       -- , pgWithTransactionSerializable
         -- * Auxiliary
       , pgRepsertRow
       ) where

import Control.Applicative
import Control.Monad
import Control.Monad.Base
import Control.Monad.Logger
import Control.Monad.Trans.Control
import Data.Int ( Int64 )
import Data.Monoid
import Data.Proxy ( Proxy(..) )
import Data.Typeable ( Typeable )
import Database.PostgreSQL.Query.Entity
import Database.PostgreSQL.Query.Internal
import Database.PostgreSQL.Query.SqlBuilder
import Database.PostgreSQL.Query.TH
import Database.PostgreSQL.Query.Types
import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromField
import Database.PostgreSQL.Simple.ToField
import Database.PostgreSQL.Simple.Transaction

import qualified Data.Text.Encoding as T

{- | Execute query generated by 'SqlBuilder'. Typical use case:

@
let userName = "Vovka Erohin" :: Text
pgQuery [sqlExp| SELECT id, name FROM users WHERE name = #{userName}|]
@

Or

@
let userName = "Vovka Erohin" :: Text
pgQuery $ Qp "SELECT id, name FROM users WHERE name = ?" [userName]
@

Which is almost the same. In both cases proper value escaping is performed
so you stay protected from sql injections.

-}

pgQuery
  :: (HasPostgres m, MonadLogger m, ToSqlBuilder q, FromRow r)
  => q
  -> m [r]
pgQuery = pgQueryWithMasker defaultLogMasker

-- | Execute arbitrary query and return count of affected rows
pgExecute
  :: (HasPostgres m, MonadLogger m, ToSqlBuilder q)
  => q
  -> m Int64
pgExecute = pgExecuteWithMasker defaultLogMasker

pgQueryWithMasker
  :: (HasPostgres m, MonadLogger m, ToSqlBuilder q, FromRow r)
  => LogMasker
  -> q
  -> m [r]
pgQueryWithMasker masker q = withPGConnection $ \c -> do
    (queryBs, logBs) <- liftBase $ runSqlBuilder c masker $ toSqlBuilder q
    logDebugN $ T.decodeUtf8 logBs
    liftBase $ query_ c queryBs

pgExecuteWithMasker
  :: (HasPostgres m, MonadLogger m, ToSqlBuilder q)
  => LogMasker
  -> q
  -> m Int64
pgExecuteWithMasker masker q = withPGConnection $ \c -> do
    (queryBs, logBs) <- liftBase $ runSqlBuilder c masker $ toSqlBuilder q
    logDebugN $ T.decodeUtf8 logBs
    liftBase $ execute_ c queryBs

-- | Executes arbitrary query and parses it as entities and their ids
pgQueryEntities :: ( ToSqlBuilder q, HasPostgres m, MonadLogger m, Entity a
                  , FromRow a, FromField (EntityId a))
                => q -> m [Ent a]
pgQueryEntities q =
    map toTuples <$> pgQuery q
  where
    runTrans con = liftLevel $ control $ \runInIO -> do
      withTransaction con $ runInIO action
    runSP con = liftLevel $ control $ \runInIO -> do
      withSavepoint con $ runInIO action

-- | Execute query inside savepoint. Requires monad to be a monad of transaction
-- or savepoint at least
pgWithSavepoint
  :: ( MonadTransaction n m, MonadBaseControl IO n
     , ('S level) ~ TransactionLevel m ) --  NOTE: we must be at least in transaction
  => n a
  -> m a
pgWithSavepoint action = do
  con <- askConnection
  liftLevel $ control $ \runInIO -> do
    withSavepoint con $ runInIO action

-- | Wrapper for 'withTransactionMode': Execute an action inside a SQL
-- transaction with a given transaction mode.
pgWithTransactionMode
  :: ( MonadTransaction n m, 'Z ~ TransactionLevel m
     , MonadBaseControl IO n )
  => TransactionMode
  -> n a
  -> m a
pgWithTransactionMode tmode ma = do
  con <- askConnection
  liftLevel $ control $ \runInIO -> do
    withTransactionMode tmode con $ runInIO ma

-- -- | Wrapper for 'withTransactionModeRetry': Like 'pgWithTransactionMode',
-- -- but also takes a custom callback to determine if a transaction
-- -- should be retried if an SqlError occurs. If the callback returns
-- -- True, then the transaction will be retried. If the callback returns
-- -- False, or an exception other than an SqlError occurs then the
-- -- transaction will be rolled back and the exception rethrown.
-- pgWithTransactionModeRetry :: (MonadPostgres m, MonadBaseControl IO m, TransactionSafe m)
--                            => TransactionMode
--                            -> (SqlError -> Bool)
--                            -> m a
--                            -> m a
-- pgWithTransactionModeRetry tmode epred ma = withPGConnection $ \con -> do
--     control $ \runInIO -> do
--         withTransactionModeRetry tmode epred con $ runInIO ma

-- -- | Wrapper for 'withTransactionSerializable': Execute an action
-- -- inside of a 'Serializable' transaction. If a serialization failure
-- -- occurs, roll back the transaction and try again. Be warned that
-- -- this may execute the IO action multiple times.
-- --
-- -- A Serializable transaction creates the illusion that your program
-- -- has exclusive access to the database. This means that, even in a
-- -- concurrent setting, you can perform queries in sequence without
-- -- having to worry about what might happen between one statement and
-- -- the next.
-- pgWithTransactionSerializable :: (MonadPostgres m, MonadBaseControl IO m, TransactionSafe m)
--                               => m a
--                               -> m a
-- pgWithTransactionSerializable ma = withPGConnection $ \con -> do
--     control $ \runInIO -> do
--         withTransactionSerializable con $ runInIO ma


{- | Perform repsert of the same row, first trying "update where" then
"insert" with concatenated fields. Which means that if you run

@
pgRepsertRow "emails" (MR [("user_id", mkValue uid)]) (MR [("email", mkValue email)])
@

Then firstly will be performed

@
UPDATE "emails" SET email = 'foo@bar.com' WHERE "user_id" = 1234
@

And if no one row is affected (which is returned by 'pgExecute'), then

@
INSERT INTO "emails" ("user_id", "email") VALUES (1234, 'foo@bar.com')
@

will be performed

-}

pgRepsertRow
  :: ( MonadPostgres m, MonadLogger m
     , ToMarkedRow wrow, ToMarkedRow urow)
  => FN                         -- ^ Table name
  -> wrow                       -- ^ where condition
  -> urow                       -- ^ update row
  -> m ()
pgRepsertRow tname wrow urow = do
    let wmr = toMarkedRow wrow
    aff <- pgExecute $ updateTable tname urow
           [sqlExp|WHERE ^{mrToBuilder "AND" wmr}|]
    when (aff == 0) $ do
        let umr = toMarkedRow urow
            imr = wmr <> umr
        _ <- pgExecute $ insertInto tname imr
        return ()
