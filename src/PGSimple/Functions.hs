module PGSimple.Functions
       ( -- * One-query functions for 'HasPostgres' instances
         pgQuery
       , pgReturning
       , pgExecute
       , pgExecuteMany
         -- * Inserting entities
       , pgInsertEntity
       , pgInsertManyEntities
         -- * Selecting entities
       , pgSelectEntities
       , pgSelectJustEntities
       , pgGetEntity
       , pgGetEntityBy
         -- * Deleting entities
       , pgDeleteEntity
         -- * Updating entities
       , pgUpdateEntity
         -- * Counting entities
       , pgSelectCount
       ) where

import Prelude

import Blaze.ByteString.Builder ( toByteString )
import Control.Applicative
import Control.Monad.Base
import Data.Int ( Int64 )
import Data.Maybe ( listToMaybe )
import Data.Proxy ( Proxy(..) )
import Data.Text ( Text )
import Data.Typeable ( Typeable )
import Database.PostgreSQL.Simple
    ( ToRow, FromRow, execute_,
      returning, query_, query, executeMany, execute )
import Database.PostgreSQL.Simple.FromField
    ( FromField )
import Database.PostgreSQL.Simple.ToField
    ( ToField )
import Database.PostgreSQL.Simple.Types
    ( Query(..), Only(..), (:.)(..) )
import PGSimple.Internal
import PGSimple.SqlBuilder
import PGSimple.TH
import PGSimple.Types

-- | Execute query generated by 'SqlBuilder'. Typical use case:
-- @
-- let userName = "Vovka Erohin" :: Text
-- pgQuery [sqlExp| SELECT id, name FROM users WHERE name = #{userName}|]
-- @
--
-- Or
--
-- @
-- let userName = "Vovka Erohin" :: Text
-- pgQuery $ Qp "SELECT id, name FROM users WHERE name = ?" [userName]
-- @
--
-- Which is almost the same. In both cases proper value escaping is
-- performed
pgQuery :: (HasPostgres m, ToSqlBuilder q, FromRow r)
        => q -> m [r]
pgQuery q = withPGConnection $ \c -> liftBase $ do
    b <- runSqlBuilder c $ toSqlBuilder q
    query_ c b

pgReturning :: (HasPostgres m, ToRow q, FromRow r)
            => Query -> [q] -> m [r] --  FIXME: make many rows interpolatable with builder
pgReturning q ps =
    withPGConnection
    $ \c -> liftBase
            $ returning c q ps

pgExecute :: (HasPostgres m, ToSqlBuilder q)
          => q -> m Int64
pgExecute q = withPGConnection $ \c -> liftBase $ do
    b <- runSqlBuilder c $ toSqlBuilder q
    execute_ c b

pgExecuteMany :: (HasPostgres m, ToRow q)
              => Query -> [q] -> m Int64 --  FIXME: make many rows interpolatable
pgExecuteMany q ps =
    withPGConnection $ \c -> liftBase $ executeMany c q ps

pgInsertEntity :: forall a m. (HasPostgres m, Entity a,
                         ToRow a, FromField (EntityId a))
               => a
               -> m (EntityId a)
pgInsertEntity a = do
    pgQuery [sqlExp|^{insertEntity a} RETURNING id|] >>= \case
        ((Only ret):_) -> return ret
        _       -> fail "Query did not return any response"


-- | Select entities as pairs of (id, entity).
--
-- @
-- handler :: Handler [Ent a]
-- handler = do
--     pgSelectEntities False Nothing
--         "WHERE field = ? ORDER BY field2" [10]
--
-- handler2 :: Handler [Ent a]
-- handler2 = do
--     pgSelectEntities False (Just "t")
--         (mconcat
--          [ " AS t INNER JOIN table2 AS t2 "
--          , " ON t.t2_id = t2.id "
--           " WHERE t.field = ? ORDER BY t2.field2" ])
--         [10]
--    -- Here the query will be: SELECT ... FROM tbl AS t INNER JOIN ...
-- @
pgSelectEntities :: forall m a q. ( Functor m, HasPostgres m, Entity a
                            , FromRow a, ToSqlBuilder q, FromField (EntityId a) )
                 => ([Text] -> [Text])
                 -> q            -- ^ part of query just after __SELECT .. FROM table__
                 -> m [Ent a]
pgSelectEntities fpref q = do
    map toTuples <$> pgQuery selectQ
  where
    toTuples ((Only eid) :. entity) = (eid, entity)
    p = Proxy :: Proxy a
    selectQ = [sqlExp|^{selectEntity (entityFieldsSimple fpref) p} ^{q}|]


-- | Same as 'pgSelectEntities' but do not select id
pgSelectJustEntities :: forall m a q. ( Functor m, HasPostgres m, Entity a
                                 , FromRow a, ToSqlBuilder q )
                     => ([Text] -> [Text])
                     -> q
                     -> m [a]
pgSelectJustEntities fpref q = do
    let p = Proxy :: Proxy a
    pgQuery [sqlExp|^{selectEntity (entityFields id fpref) p} ^{q}|]


-- | Select entity by id
--
-- @
-- getUser :: EntityId User ->  Handler User
-- getUser uid = do
--     pgGetEntity uid
--         >>= maybe notFound return
-- @
pgGetEntity :: forall m a. (ToField (EntityId a), Entity a,
                      HasPostgres m, FromRow a, Functor m)
            => EntityId a
            -> m (Maybe a)
pgGetEntity eid = do
    listToMaybe <$> pgSelectJustEntities id [sqlExp|WHERE id = #{eid} LIMIT 1|]


-- | Get entity by some fields constraint
--
-- @
-- getUser :: UserName -> Handler User
-- getUser name = do
--     pgGetEntityBy
--         [("name" :: Query, toField name),
--          ("active", toField True)]
--         >>= maybe notFound return
-- @
--
-- The query here will be like
--
-- @
-- pgQuery "SELECT id, name, phone ... FROM users WHERE name = ? AND active = ?" (name, True)
-- @
pgGetEntityBy :: forall m a b. (Entity a, HasPostgres m, ToMarkedRow b,
                          FromField (EntityId a), FromRow a, Functor m)
              => b               -- ^ uniq constrained list of fields and values
              -> m (Maybe (Ent a))
pgGetEntityBy f = (error "FIXME: ") -- someGetEntityBy pgQuery f


-- | Same as 'pgInsertEntity' but insert many entities at on action
pgInsertManyEntities :: forall a m. (Entity a, HasPostgres m, ToRow a)
                     => [a]
                     -> m ()
pgInsertManyEntities a = (error "FIXME: ") --  someInsertManyEntities pgExecuteMany a


-- | Delete entity.
--
-- @
-- rmUser :: EntityId User -> Handler ()
-- rmUser uid = do
--     pgDeleteEntity uid
-- @
pgDeleteEntity :: forall a m. (Entity a, HasPostgres m, ToField (EntityId a), Functor m)
               => EntityId a
               -> m ()
pgDeleteEntity eid = (error "FIXME: ") -- someDeleteEntity pgExecute eid


-- | Update entity using 'ToMarkedRow' instanced value. Requires 'Proxy' while
-- 'EntityId' is not a data type.
--
-- @
-- fixVovka :: EntityId User -> Handler ()
-- fixVovka uid = do
--     pgGetEntity uid
--         >>= maybe notFound run
--   where
--     run user =
--         when ((userName user) == "Vovka")
--         $ pgUpdateEntity uid
--         (Proxy :: Proxy User)
--         [("active" :: Query, toField False)]
-- @
pgUpdateEntity :: forall a b m. (ToMarkedRow b, Entity a, HasPostgres m,
                           ToField (EntityId a), Functor m, Typeable a, Typeable b)
               => EntityId a
               -> b
               -> m ()
pgUpdateEntity eid prm = (error "FIXME: ") -- someUpdateEntity pgExecute eid prm

-- someSelectCount :: Proxy a -> Query -> prms -> m Integer

-- | Select count of entities with given query
--
-- @
-- activeUsers :: Handler Integer
-- activeUsers = do
--     pgSelectCount (Proxy :: Proxy User)
--         "WHERE active = ?" [True]
-- @
pgSelectCount :: forall m a prm. (Entity a, HasPostgres m, ToRow prm, Functor m)
              => Proxy a
              -> Query
              -> prm
              -> m Integer
pgSelectCount q prm = (error "FIXME: ") -- someSelectCount pgQuery q prm
